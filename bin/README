###############################################################################
README for Software Development Environment (SDE)
###############################################################################

This document contains important information about how to use the
software development environment (SDE) installed in the lab.

###############################################################################

Software Development Environment (SDE)

The directory hierarchy in which this README file resides contains
the files for a complete C++/C software development environment (SDE).
This SDE includes the following packages:
    * GCC
    * Clang
    * CMake
    * TexLive
    * JasPer
In addition, the SDE contains some scripts for managing the SDE itself.

As a matter of terminology, the top-level directory of the SDE is the
directory that contains this README file.
This directory probably looks something like:
    /home/frodo/public/ugls_lab (for machines in the UGLS Lab ELW B326)
    or
    /home/frodo/public/linux_lab (for machines in the Linux Lab ELW B215)
    or
    /home/frodo/public/dsp_lab (for machines in the DSP lab).
For the remainder of this document, $SDE_TOP_DIR will be used to denote
the top-level directory of the SDE.
Consequently, all later occurences of $SDE_TOP_DIR in this document
should be read as if they were replaced by the top-level directory of the SDE.

###############################################################################

Initializing the SDE

In order for the SDE to be used, it must first be initialized.  This can
be accomplished via the sde_shell or sde_make_setup commands as described
below.  Of these two commands, sde_shell is simpler to use.

The sde_shell Command

The sde_shell command will start a new shell that is initialized to use the
SDE.  In the case of the bash shell, a modified command prompt is employed
by the new shell in order to make clear that the SDE
is being used.  The above command ensures that various environment
variables are set correctly for the compiler, linker, and/or dynamic
linker.  This initialization must be done correctly or it may not be
possible to compile, link, and/or execute programs.

To invoke the sde_shell command, type:
    $SDE_TOP_DIR/bin/sde_shell

The sde_make_setup Command

The sde_make_setup command simply prints (to standard output) the commands
necessary for a particular shell to initialize the SDE.  Currently, this
command only supports the bash and tcsh shells.  Since the sde_make_setup
command only prints the commands required for initialization without
causing them to be executed, it is the responsibility of the user to use
the printed commands appropriately (i.e., by executing them).  How this
is done depends on the particular shell being used.

To invoke the sde_make_setup command, causing it to print the sequence
of commands required for initialization in the case of the shell $shell,
where $shell is either bash or tcsh, type:
    $SDE_TOP_DIR/bin/sde_make_setup -s $shell
Of course, simply running the preceding command does not actually
do any initialization since it only prints commands without causing
them to be executed.

If you use the bash shell, you can run sde_make_setup and cause the
commands output by sde_make_setup to be executed by typing:
    eval `$SDE_TOP_DIR/bin/sde_make_setup -s bash`
Furthermore, by adding the preceding command to your bash_profile file
(i.e., $HOME/.bash_profile), you can initialize the SDE automatically
in each new bash shell that you start.  (Note that adding the command
to your bashrc file may not work, since, on some systems, the login shell
does not read the bashrc file.)

If you use the tcsh shell, you can run sde_make_setup and cause the
commands output by sde_make_setup to be executed by typing:
    eval `$SDE_TOP_DIR/bin/sde_make_setup -s tcsh`
Furthermore, by adding this command to your tcshrc file (i.e.,
$HOME/.tcshrc) or login file (i.e., $HOME/.login), you can initialize
the SDE automatically in each new tcsh shell that you start.

###############################################################################

Using the SDE (After Initialization)

After the SDE has been initialized, all of the commands that are part
of the SDE should be on your (command) search path.  The commands that
are most likely to be of interest are as follows:

    g++
    gcc
    clang++
    clang
    cmake
    ctest
    latex
    pdflatex
    gdb
    imgcmp

Do not change the PATH environment variable, except
through the use of the sde_shell or sde_make_setup commands.

Do not add /usr/include to the include search path.

Do not add /lib, /lib64, /usr/lib, /usr/lib64, or other such
directories to the library search path.

Do not change the LD_LIBRARY_PATH environment variable, except
through the use of the sde_shell or sde_make_setup commands.

###############################################################################

Comments Specific to the UGLS Lab (ELW B326)
[These comments are for students in ELEC 486/586, as they use the UGLS Lab.]

The SDE should work on all machines in the UGLS Lab.

All of the libraries (including their corresponding header files) used
in ELEC 486/586 are installed in directories that are automatically searched
by the compiler.  Therefore, it should not be necessary to provide options
to g++ to add directories to the include search path or library search path.

The top-level directory for the SPL library, which is referred to as
"$SPL_TOPDIR" on various course handouts for ELEC 486/586, is:
   $SDE_TOP_DIR/SPL
(where "$SDE_TOP_DIR" is as defined earlier).

###############################################################################

Comments Specific to the DSP Lab (ELW B234)
[These comments are for the graduate students of Michael Adams, as they
use the DSP Lab.]

The compiler should work on most (or all) of the 64-bit Intel machines
in the DSP lab.  This includes, but is not limited to:

    jasper
    yoho
    king

It would be very wise to try various machines and compare their speeds.
Some machines are much faster than others.  The machine jasper is NOT the
fastest, and in fact it might be the slowest since it is a file server.
For example, some preliminary testing suggests that king may be much
faster than jasper.

###############################################################################

